:toc:
:toclevels: 4

= `thincrest-pcond`: Test Assertion Library



`thincrest-pcond` is a test assertion library named after `hamcrest` and it is at the same time a pun for "think the rest".
It uses `pcond`, which provides you with Java's predicates that can print descriptive message on a failure, instead of `Matcher` used by `hamcrest`.
The benefit of `pcond` over `hamcrest` is its compatibility and extensibility.
Instead of "matchers" that `hamcrest` uses to verify values, `pcond` uses Java's plain `Predicate` and provide useful preset predicates from which you can build your own predicates for complex types.
So, you can reuse the predicates you created for assertions for other purposes, such as value checking and testing.
It is why it is "thinner" than `hamcrest`.

For full documentation, visit https://dakusui.github.io/thincrest/[here].

== Getting Started

Have a following maven dependency in your `pom.xml`.

[source,xml]
[subs="verbatim,attributes"]
----
<dependency>
  <groupId>com.github.dakusui</groupId>
  <artifactId>thincrest-pcond</artifactId>
  <version>{thincrest-pcond-version}</version>
</dependency>
----

Visit https://oss.sonatype.org/[oss.sonatype.org] to figure out the most recent version of `thincrest-pcond`.

== Programming with `pcond-thincrest`

Following is the first example of the `thincrest-pcond` library.

[%nowrap,java]
.ThincrestExample.java
----
public class ThincrestExample {
  @Test
  public void testString() {
    assertThat(
        "hello World",
        transform(function("toUpperCase", o -> Objects.toString(o).toUpperCase())) // <1> <2>
            .check(containsString("HELLO"))); // <3>
  }
}
----
<1> `Predicates.transform(Function<,>)`
<2> `Printables.function(String, Function<,>)`
<3> `Predicates.containsString(String)`

For readability's sake, it's recommended to extract a function, where possible.

[%nowrap,java]
.ThincrestExample.java
----
public class ThincrestExample {
  @Test
  public void testString() {
    assertThat(
        "hello World",
        transform(toUpperCase()).check(containsString("HELLO")));
  }

  private static Function<String, String> toUpperCase() {
    return function("toUpperCase", o -> Objects.toString(o).toUpperCase());
  }
}
----

The programming style of `thincrest-pcond` (or `pcond` in more general) is to first transform a given value into better known type or form, which is more suitable for examining its validity.

In this example, a given string is first transformed into all upper cases so that it is equal to "HELLO" if we ignore cases.

This results in a following output.

.Output of Example.java
|===
|Expectation |Actual

a|
[%nowrap]
----
    "Howdy, World"->transform:toUpperCase       ->"HOWDY, WORLD"
[0] "HOWDY, WORLD"->check:containsString[hello] ->true

.Detail of failure [0]
---
containsString[hello]
---
----
a|
[%nowrap]
----
    "Howdy, World"->transform:toUpperCase       ->"HOWDY, WORLD"
[0] "HOWDY, WORLD"->check:containsString[hello] ->false

.Detail of failure [0]
---
HOWDY, WORLD
---
----
|===

You can see the violated condition and how it is violated in the stacktrace.

A philosophy behind `thincrest-pcond` 's approach is:

- A human in the end check the value on a screen as a text.
- Either way, test can only report a presence of a bug, cannot ensure absence of it.
If so, rather than trying to build "matcher", "subject", or "assertion" objects that can do a check that detects all the bugs for a given class, it will be more productive to decompose the check into various checks, each of which is concise and understandable.

=== "Printable" Predicate

To verify a value with `thincrest` or `valid8j`, you can call a value checking method of them with your value and a predicate to be checked.

[source]
----
valueCheckingMethod(aValue, predicate);
----

A valud checking methods are defined as public static methods in classes, such as `TestAssertions`(`thincrest-pcond`) or `Requires`(`valid8j-pcond`).
It is recommended to import them statically at the beginning of your class.

You can give your own lambda as a predicate to the method, however it will result in non-user friendly string such as following.

[source]
----
Exception in thread "main" java.lang.IllegalArgumentException: value:"JohnDoe" violated precondition:value java.util.function.Predicate$$Lambda$78/2047329716@46f7f36a
----

This is still better than nothing, however, probably it will be much better if you can see what a condition the value "JohnDoe" violated and how it did without visiting the source code.
In order to make `thincrest` and valid8j` print such a message on a failure, you need to give a "printable" predicate, which we will be describing here.

`pcond`, which powers `thincrest` and valid8j`, offers a set of method to create a printable predicate in `Predicates` class.
It also offers a way to construct a conjunction, disjunction, and negation of given printable predicates.

Following is an example.

----
and(isNotNull(), transform(length()).check(gt(0)), containsString(" "))
----

`isNotNull` is a method that returns a predicate which returns `true` if a value given to `test` method is not `null`.
And its `toString` method is overridden so that it returns a string `isNotNull`.

`and` is another method that returns a printable predicate.
The method accepts predicates and constructs a new printable predicate that is a conjunction of them.

`transform` and `check` structure needs a bit more explanation than others.

----
transform(length()).check(gt(0))
----

This line constructs a printable predicate which returns `true` if a length of a given string is greater than (`gt`) 0.

NOTE: This is a little artificial example to illustrate the usage of the `transform` and `check` structure.
You can achieve the same thing with `Predicates.isEmptyString()` and it will be simpler and faster.

First the method `transfom` accepts, preferably a printable, function.
In this case a function returned by `length` method, which is defined in `Functions` class, is passed to the method.
Now it returns a factory for a printable predicate.
The `check` method of the factory returns a new predicate that checks a transformed value by the first function.
With this `transform` and `check` approach, you can build various printable predicates from preset ones.

=== Examining a Value: Value Checking Methods

==== Conventional Value Checking Methods of `thincrest-pcond`



`assertThat` (`TestAssertions`):: (t.b.d.)
`assumeThat` (`TestAssertions`):: (t.b.d)

==== FLuent Value Checking Methods of `thincrest-pcond`

`assertStatement` (`TestFluents`):: (t.b.d.)
`assertAll` (`TestCluents`):: (t.b.d.)
`assumeStatement` (`TestFluents`):: (t.b.d.)
`assumeAll` (`TestFluents`):: (t.b.d.)

==== Conventional Value Checking Methods of `valid8j-pcond`

Depending on the context, where you are going to examine a given value, an appropriate message and exception to be thrown on a failure can be different.
`pcond` provides methods that offer such messages and exceptions.
You can simply call methods with the value and the condition you are going to examine.
Followings are methods for it and classes in which they are defined.

`requireXyz` (`Preconditions`):: Methods for checking "preconditions", which a user of your product needs to satisfy.
On a failure, a `RuntimeException` such as `NullPointerException` etc. will be thrown depending on the actual method.
`Xyz` can be `NonNull`, `Argument`, or `State`.
`ensureXyz` (`Postconditions`):: Methods for checking "postconditions" , which your product needs to satisfy for its user.
These methods also throw `RuntimeException` s depending on a actual prefix `Xyz` .
`Xyz` can be `NonNull` or `State`.
`validate` (`Validations`):: This is also used for checking "preconditions".
However, unlike `requireXyz` methods, it throws an `ApplicationException`, which is a checked exception (not a `RuntimeException`).
This method should be used in a situation where a "recoverable" failure happens.
`assert xyz` (`Assertions`):: This should be used for checking "internal" error, where you want to disable the check in production code.
`xyz` can be `precondition`, `postcondition`, `invariant` and `that`.
The usege of the first three is self-explanatory.
`that` is used for the other purposes.
In case you want to use `assert` for any other purposes than them, use `that`.

To check your user's fault, use `requireXyz` or `validate`.
When there is a simple and easy way to check the condition, use `requireXyz`.
Otherwise, use `validate` to allow your user to handle the error.
To check your own fault, use `ensureXyz` or `assert xyz`.
If the check should be done even in the production, i.e. it can be broken by your user, use `ensureXyz`.
Otherwise, use `assert xyz`.
Because the check can only be broken by your own fault (bug), which should not exist in your production code.

Among all of those, `assert xyz` has a quite outstanding characteristic, where it can be completely disabled by `-da` option to your JVM and does not have any performance overhead at all if it is disabled.


==== Fluent Value Checking Methods of `valid8j-pcond`

Following is a list of "Fluent" versions of value checking methods of `valid8j-pcond`.
They are defined in `ValidationFluens' class.

A general naming convention of them is:

- *requireXyz(...):* A method to define a precondition for Xyz
- *ensureXyz(...):* A method to define a post-condition for Xyz

If `Xyz` is:

- *singular:* A method that accepts a single `Statement`.
- *plural:* A method that accepts multiple `Statement` s.
Conditions for the statements are connecrted by `Predicates#allOf` method.

`Xyz` can be `Argument`, `Statement`, `State`

`precondition`, `preconditions`
`that`, `all`
`postcondition`, `preconditions`

[cols="1,3,3,3"]
|===
|              |Argument |State| Condition

|precondition
a|
- requireArgument
- requireArguments
a|
- requireState
- requireStates
a|
- requireStatement
- requireAll

|invariant
|
|
|

|postcondition

|
a|
- ensureState
- ensureStates
a|
- ensureStatement
- ensureAll
|===

Argument
State
Statement

Precondition
Invariant
Post-condition

singular
plural

require,ensure
assert


requireArgument(Statement<T> statement):: Fluent version of Requires#requireArgument(Object, Predicate)} (Object, Predicate)`.
requireArguments(Statement<?>... statements):: Fluent version of `Requires#requireArgument(Object, Predicate)`.
Use this method when you need to verify multiple values.
requireStatement(Statement<T> statement):: Fluent version of `Requires#require(Object, Predicate)`.
requireAll(Statement<?>... statements):: Fluent version of
Use this method when you need to verify multiple values.
requireState(Statement<T> statement):: Fluent version of `Requires#requireState(Object, Predicate)`.
requireStates(Statement<T>... statements):: Fluent version of `Requires#requireState(Object, Predicate)`.
Use this method when you need to verify multiple values.
ensureStatement(Statement<T> statement):: Fluent version of `Ensures#ensure(Object, Predicate)`.
ensureAll(Statement<T>... statements):: Fluent version of `Ensures#ensure(Object, Predicate)`.
Use this method when you need to verify multiple values.
ensureState(Statement<T> statement):: Fluent version of `Ensures#ensureState(Object, Predicate)`.
ensureStates(Statement<T>... statements):: Fluent version of `Ensures#ensureState(Object, Predicate)`.
Use this method when you need to verify multiple values.
that(Statement<T> statement):: Fluent version of `Assertions#that(Object, Predicate)`.
* Use this method when you need to verify multiple values.
all(Statement<T>... statements):: Fluent version of `Assertions#that(Object,Predicate)`.
Use this method when you need to verify multiple values.
precondition(Statement<T> statement):: Fluent version of `Assertions#precondition(Object, Predicate)`.
Use this method when you need to verify multiple values.
preconditions(Statement<T>... statements):: Fluent version of `Assertions#precondition(Object, Predicate)`.
Use this method when you need to verify multiple values.
postcondition(Statement<T> statement):: Fluent version of `Assertions#postcondition(Object, Predicate)`.
postconditions(Statement<T>... statements):: Fluent version of `Assertions#postcondition(Object, Predicate)`.
Use this method when you need to verify multiple values.

=== Reading the Output

Look at the first line of the output you see in a failure.
There's a message:

----
value:"JohnDoe" violated precondition:value ((isNotNull&&!isEmpty)&&containsString[" "])
----

This is describing the value that was examined and the condition violated by it.

The next several lines explain how a given value violated a condition to be satisfied.

----
&&                               -> false
  isNotNull("JohnDoe")           -> true
  transformAndCheck              -> true
    length("JohnDoe")            -> 7
    >[0](7)                      -> true
  containsString[" "]("JohnDoe") -> false
----

See the last line, this means the given string `JohnDoe` made a condition `containsString[" "]` `false`, and it made the entire check fail.
`pcond` is designed to shortcut an evaluation as soon as a value of a disjunctive or conjunctive predicate becomes fixed.
That is, if you have an `or` condition, and the first predicate under it becomes `true`, the rest will not be evaluated at all.
So the last line in the message always shows the direct reason why the check failed.

Thus, you can read the output above as "The check failed because the value `\"JohnDoe\"` `containsString[" "]` was `false`.
"

=== Writing your Code Fluently

Following is an example that illustrates how to use "Fluent" API of `thincrest-pcond` to build a test.

[source,java]
----
public class FluentExample {
  public void assertSalute() {
    Salute salute = new Salute();
    assertStatement(                  // <1>
        objectValue(salute)           // <2>
            .invoke("inJapanese")     // <3>
            .asString()               // <4>
            .length()                 // <5>
            .then()                   // <6>
            .greaterThan(2));         // <7>
  }
}
----

<1> `TestFluents.assertStatement(...)`.
This method takes one `Statement` as a parameter.
<2> `Statement.objectValue(...)` ObjectTransformer
<3> `invoke(String methodName, Object... args)` is a method to invoke a method on an object given to `objectValue`.
Usually you can specify a method that you want to test.
This method returns `ObjectTransformer` since you cannot make any assumption on the type at compile-time.
<4> You need to let the compiler know you want to use `StringTransformer` for the returned value, instead of `ObjectTransformer`.
<5> This method calls `String#length()` method on the current object and returns `IntegerTransformer`.
<6> Let the current transformer know that now you want to check the transformed value.
This method returns a corresponding checker, in this case, it will be `IntegerChecker`.
<7> Add a check if the current value is greater than 2 to the current checker.
Since `Checker` is extending `Statement`, this compiles without calling a builder method to make it a `Statement` instance.

You can build a more complex assertion for your test using `transform(...)` method.

[source,java]
----
public class FluentExample {
  public void assertAllSalutes() {
    Salute salute = new Salute();
    assertAll(                                  // <1>
        objectValue(salute)
            .invoke("inJapanese")
            .asString()
            .length()
            .then()
            .greaterThan(2),
        objectValue(salute)
            .invoke("inEnglish")
            .asString()
            .transform(                         // <2>
                v -> allOf(v.length().then()    // <3>
                            .greaterThan(10)
                            .toPredicate(),     // <4>
                           v.then()
                            .contains("Hello")
                            .toPredicate())));
  }
}
----

<1> To assert multiple statements at once, use `TestAssertions.assertAll(Statement... statements)`.
<2> `transform(Function<XyzTransfomer<Xya>, Predicate<Xyz> clause)`
<3> `Predicates.allOf(Predicate<> ...)` can be used here to branch the checking procedure.
In this case, we want to check if a salute in English is longer than ten characters, and it contains a word `"Hello"`.
<4> A checker has a method `toPredicate()`, which builds a printable predicate from the conditions that have been added to it.

In case of a failure, the test above will print a message like following:

|===
|Expected |Actual

a|
[%nowrap,text]
----
    ThincrestExample$Salute@6e3c1e69->WHEN:transform              ->true
                                    ->    <>.inJapanese()         ->"こんにちは"
    "こんにちは"                     ->    castTo[String]          ->"こんにちは"
                                    ->    length                  ->5
    5                               ->  THEN:>[2]                 ->true
    ThincrestExample$Salute@1888ff2c->WHEN:transform              ->true
                                    ->    <>.inEnglish()          ->""
    ""                              ->    castTo[String]          ->""
                                    ->  THEN:allOf                ->true
                                    ->    transform:length        ->0
[0] 0                               ->    THEN:>[10]              ->true
[1] ""                              ->      containsString[Hello] ->true

.Detail of failure [0]
---
>[2]
---

.Detail of failure [1]
---
containsString[Hello]
---

----
a|
[%nowrap,text]
----
    ThincrestExample$Salute@6e3c1e69->WHEN:transform              ->true
                                    ->    <>.inJapanese()         ->"こんにちは"
    "こんにちは"                      ->    castTo[String]          ->"こんにちは"
                                    ->    length                  ->5
    5                               ->  THEN:>[2]                 ->true
    ThincrestExample$Salute@1888ff2c->WHEN:transform              ->false
                                    ->    <>.inEnglish()          ->""
    ""                              ->    castTo[String]          ->""
                                    ->  THEN:allOf                ->false
                                    ->    transform:length        ->0
[0] 0                               ->    THEN:>[10]              ->false  //<1>
[1] ""                              ->      containsString[Hello] ->false  //<2>

.Detail of failure [0]
---
0
---

.Detail of failure [1]
---

---
----
<1> The detail is shown in "Detail of failure[0]"
<2> The detail is shown in "Detail of failure[1]"
|===

== Using Together with `valid8j-pcond`

When you use `valid8j-pcond`, which is a twin of `thincrest-pcond`, please be careful at package names of classes you are going to use.
They both use `pcond` to render messages from predicates.
But the classes from `pcond` are stored under `com.github.dakusui.thincrest_pcond` in `thincrest-pcond`.
`valid8j` does the same.
Classes from `pcond` are stored under `com.github.dakusui.valid8j_pcond` in `valid8j-pcond`.
If you use, create a predicate using `com.github.dakusui.valid8j_pcond.forms.Predicates`, for instance, the `thincrest` 's mechanism to compose error messages from predicates cannot do the work.
Because the predicates created by `valid8j-pcond` 's classes will look just normal `Predicate`, not ones that have mechanism to print it, the message will look much poorer than it can be.

The other way around will not happen (fortunately) because `thincrest-pcond` will be a dependency in `test` scope, and it will not be visible from the production scope, which `valid8j-pcond` is usually used.

== Building the `thincrest-pcond` Library

=== How to Build the Project

Compile and Test:: `mvn clean compile test`
Docs:: `mvn clean compile test site`, you will see generated docs under `target/site` directory.

=== Build dependencies

- Java SDK8
- `mvn`
- `gem`
- `xmllint`
- `git`

[bibliography]
== References

- [[[DbC, 1]]] Wikipedia article on Design by Contract, https://en.wikipedia.org/wiki/Design_by_contract
- [[[v4j, 2]]] Valid4j, http://www.valid4j.org
- [[[GuavaPreconditions, 3]]] PreconditionsExplained, https://github.com/google/guava/wiki/PreconditionsExplained